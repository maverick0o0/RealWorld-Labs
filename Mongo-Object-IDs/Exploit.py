from datetime import datetime, timedelta

def parse_object_id(obj_id):
    if len(obj_id) != 24 or not all(c in '0123456789abcdefABCDEF' for c in obj_id):
        raise ValueError("Invalid ObjectID: Must be 24 hex characters.")
    
    obj_id = obj_id.lower()  # Normalize to lowercase
    
    timestamp_hex = obj_id[0:8]
    machine_hex = obj_id[8:14]
    process_hex = obj_id[14:18]
    counter_hex = obj_id[18:24]
    
    timestamp = int(timestamp_hex, 16)
    dt = datetime.fromtimestamp(timestamp)
    counter = int(counter_hex, 16)
    
    print(f"Timestamp (Unix): {timestamp}")
    print(f"Timestamp (Human-readable): {dt.strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Machine ID: {machine_hex}")
    print(f"Process ID: {process_hex}")
    print(f"Counter: {counter} (hex: {counter_hex})")
    
    return machine_hex, process_hex, counter  # Return counter too for suggestion

def generate_mongo_ids(start_dt, end_dt, base_counter, counter_range, machine_id, process_id):
    file_name = 'generated_mongo_ids.txt'
    with open(file_name, 'w') as file:
        current_dt = start_dt
        while current_dt <= end_dt:
            counter = base_counter
            timestamp = int(current_dt.timestamp())
            for _ in range(counter_range):
                timestamp_hex = f'{timestamp:08x}'
                machine_hex = machine_id.lower()
                process_hex = process_id.lower()
                counter_hex = f'{counter:06x}'
                
                mongo_id = f'{timestamp_hex}{machine_hex}{process_hex}{counter_hex}'
                file.write(f"{mongo_id}\n")
                counter += 1
            current_dt += timedelta(seconds=1)
    print(f"Generated {counter_range} Mongo ObjectIDs per second (starting from base_counter {base_counter}) saved in '{file_name}'.")
    if counter_range > 1000000:
        print("Warning: Large counter range will create a big file and may take time.")

# Interactive script
if __name__ == "__main__":
    # Part 1: Parse ObjectID
    obj_id = input("Enter MongoDB ObjectID (24 hex chars): ").strip()
    machine_id, process_id, parsed_counter = parse_object_id(obj_id)
    
    # Part 2: Accept start and end timestamps in user-friendly way
    start_timestamp_str = input("Enter start timestamp (YYYY-MM-DD HH:MM:SS): ").strip()
    end_timestamp_str = input("Enter end timestamp (YYYY-MM-DD HH:MM:SS): ").strip()
    try:
        start_dt = datetime.strptime(start_timestamp_str, '%Y-%m-%d %H:%M:%S')
        end_dt = datetime.strptime(end_timestamp_str, '%Y-%m-%d %H:%M:%S')
    except ValueError:
        raise ValueError("Invalid timestamp format. Use YYYY-MM-DD HH:MM:SS")
    
    # Part 3: Accept base counter (e.g., a low value like 7840000)
    base_counter_input = input(f"Enter base counter (integer, e.g., a value lower than {parsed_counter} like 7840000; default 0): ").strip()
    base_counter = int(base_counter_input) if base_counter_input else 0
    
    # Part 4: Accept counter range (e.g., enough to cover up to parsed_counter, like parsed_counter - base_counter + 1)
    suggested_range = parsed_counter - base_counter + 1 if base_counter < parsed_counter else 1000
    range_input = input(f"Enter counter range per second (number of IDs per timestamp second; suggested: {suggested_range} to cover up to parsed counter): ").strip()
    counter_range = int(range_input) if range_input else suggested_range
    
    # Generate using extracted machine and process IDs
    generate_mongo_ids(start_dt, end_dt, base_counter, counter_range, machine_id, process_id)